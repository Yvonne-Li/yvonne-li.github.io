<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en_US"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en_US" /><updated>2025-06-07T11:59:21-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yvonne Li</title><subtitle>Hello Travellers!
</subtitle><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><entry><title type="html">Llvm Ir Iteration</title><link href="http://localhost:4000/2025/06/07/LLVM-IR-Iteration.html" rel="alternate" type="text/html" title="Llvm Ir Iteration" /><published>2025-06-07T00:00:00-04:00</published><updated>2025-06-07T00:00:00-04:00</updated><id>http://localhost:4000/2025/06/07/LLVM-IR-Iteration</id><content type="html" xml:base="http://localhost:4000/2025/06/07/LLVM-IR-Iteration.html"><![CDATA[<p><strong>STL-style</strong> refers to following the design patterns and conventions established by the <strong>Standard Template Library (STL)</strong>, which is a fundamental part of the C++ standard library.</p>

<h2 id="core-stl-design-patterns">Core STL Design Patterns</h2>

<h3 id="1-iterator-pattern">1. <strong>Iterator Pattern</strong></h3>

<p>STL uses iterators as a uniform way to traverse containers:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// STL vector example</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-common-interface-conventions">2. <strong>Common Interface Conventions</strong></h3>

<p>STL containers share consistent method names:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">begin()</code> / <code class="language-plaintext highlighter-rouge">end()</code> - start/end iterators</li>
  <li><code class="language-plaintext highlighter-rouge">size()</code> - number of elements</li>
  <li><code class="language-plaintext highlighter-rouge">empty()</code> - check if container is empty</li>
  <li><code class="language-plaintext highlighter-rouge">insert()</code> / <code class="language-plaintext highlighter-rouge">erase()</code> - add/remove elements</li>
</ul>

<h3 id="3-template-based-design">3. <strong>Template-Based Design</strong></h3>

<p>STL heavily uses templates for type safety and reusability:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</code></pre></div></div>

<h2 id="how-llvm-adopts-stl-style">How LLVM Adopts STL-Style</h2>

<p>LLVM IR classes follow these same patterns:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// LLVM follows STL conventions</span>
<span class="n">Function</span><span class="o">*</span> <span class="n">F</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>

<span class="c1">// STL-style iteration</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Function</span><span class="o">::</span><span class="n">iterator</span> <span class="n">BB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">BB</span> <span class="o">!=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">BB</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">BB</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// process instruction</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// STL-style methods</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>          <span class="c1">// Like STL containers</span>
    <span class="kt">size_t</span> <span class="n">numBB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="c1">// Like STL containers</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="stl-iterator-categories">STL Iterator Categories</h2>

<p>STL defines different iterator types that LLVM also follows:</p>

<table>
  <thead>
    <tr>
      <th>Iterator Type</th>
      <th>Capabilities</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Input Iterator</strong></td>
      <td>Read-only, forward only</td>
      <td><code class="language-plaintext highlighter-rouge">istream_iterator</code></td>
    </tr>
    <tr>
      <td><strong>Output Iterator</strong></td>
      <td>Write-only, forward only</td>
      <td><code class="language-plaintext highlighter-rouge">ostream_iterator</code></td>
    </tr>
    <tr>
      <td><strong>Forward Iterator</strong></td>
      <td>Read/write, forward only</td>
      <td><code class="language-plaintext highlighter-rouge">forward_list::iterator</code></td>
    </tr>
    <tr>
      <td><strong>Bidirectional Iterator</strong></td>
      <td>Read/write, forward/backward</td>
      <td><code class="language-plaintext highlighter-rouge">list::iterator</code></td>
    </tr>
    <tr>
      <td><strong>Random Access Iterator</strong></td>
      <td>Read/write, jump to any position</td>
      <td><code class="language-plaintext highlighter-rouge">vector::iterator</code></td>
    </tr>
  </tbody>
</table>

<h2 id="stl-style-benefits">STL-Style Benefits</h2>

<h3 id="1-familiar-interface">1. <strong>Familiar Interface</strong></h3>

<p>C++ developers already know these patterns:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This feels familiar to anyone who knows STL</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Module</span><span class="o">::</span><span class="n">iterator</span> <span class="n">F</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">F</span> <span class="o">!=</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// process function</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-generic-algorithms">2. <strong>Generic Algorithms</strong></h3>

<p>Works with STL algorithms:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="c1">// Count functions in a module</span>
<span class="kt">size_t</span> <span class="n">funcCount</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// Find a specific function</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
    <span class="p">[](</span><span class="k">const</span> <span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">==</span> <span class="s">"main"</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div></div>

<h3 id="3-range-based-for-loops-c11">3. <strong>Range-Based For Loops</strong> (C++11+)</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Modern C++ range-based for loop works because of STL-style design</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">F</span> <span class="o">:</span> <span class="n">M</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">BB</span> <span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">I</span> <span class="o">:</span> <span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// process instruction</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="available-iterator-types-in-llvm">Available Iterator Types in LLVM</h2>

<p>From the document, LLVM provides these STL-style iterator types:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Different iterator types for different LLVM structures</span>
<span class="n">Module</span><span class="o">::</span><span class="n">iterator</span>        <span class="c1">// Iterates over functions in a module</span>
<span class="n">Function</span><span class="o">::</span><span class="n">iterator</span>      <span class="c1">// Iterates over basic blocks in a function  </span>
<span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span>    <span class="c1">// Iterates over instructions in a basic block</span>
<span class="n">Value</span><span class="o">::</span><span class="n">use_iterator</span>     <span class="c1">// Iterates over uses of a value</span>
<span class="n">User</span><span class="o">::</span><span class="n">op_iterator</span>       <span class="c1">// Iterates over operands of a user</span>
</code></pre></div></div>

<h2 id="comparison-stl-style-vs-custom-approaches">Comparison: STL-Style vs Custom Approaches</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// STL-style (what LLVM uses)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Function</span><span class="o">::</span><span class="n">iterator</span> <span class="n">BB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">BB</span> <span class="o">!=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Standard, predictable interface</span>
<span class="p">}</span>

<span class="c1">// Hypothetical custom approach (what LLVM could have done differently)</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">getBasicBlockCount</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BasicBlock</span><span class="o">*</span> <span class="n">BB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">getBasicBlock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// Less familiar, inconsistent across different classes</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The STL-style approach makes LLVM more approachable for C++ developers because they can leverage their existing knowledge of STL patterns and conventions. This design choice reduces the learning curve and makes the API more intuitive and consistent.</p>]]></content><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><summary type="html"><![CDATA[STL-style refers to following the design patterns and conventions established by the Standard Template Library (STL), which is a fundamental part of the C++ standard library.]]></summary></entry><entry><title type="html">Software Testing</title><link href="http://localhost:4000/2025/05/22/Introduction-to-Software-Testing.html" rel="alternate" type="text/html" title="Software Testing" /><published>2025-05-22T00:00:00-04:00</published><updated>2025-05-22T00:00:00-04:00</updated><id>http://localhost:4000/2025/05/22/Introduction%20to%20Software%20Testing</id><content type="html" xml:base="http://localhost:4000/2025/05/22/Introduction-to-Software-Testing.html"><![CDATA[<p>Status: #review  #knowledge <br />
Tags: #SAT #testing #softwaredev</p>

<h1 id="cs6340-sat---introduction-to-software-testing">CS6340 SAT - Introduction to Software Testing</h1>
<h2 id="observations">Observations</h2>
<h3 id="the-need-for-specifications">the need for specifications</h3>
<ul>
  <li>testing checks whether program implementation agrees with program specification</li>
  <li>without a specification, there’s nothing to test</li>
  <li>testing a form of consistency checking between implementation and specification
    <ul>
      <li>recurring theme for software quality checking approaches</li>
      <li>what if implementation and specification are wrong?
        <h3 id="developer-tester">developer !=Tester</h3>
      </li>
    </ul>
  </li>
  <li>developer writes implementation, tester writes specification</li>
  <li>unlikely that both will independently make the same mistake</li>
  <li>Specifications useful even if written by developer itself
    <ul>
      <li>much simpler than implementation</li>
      <li>specification unlikely to have same mistake as implementation
        <h3 id="other-observations">Other observations</h3>
      </li>
    </ul>
  </li>
  <li>resources are finite
    <ul>
      <li>limit how many tests are written</li>
      <li>specifications evolve over time
        <ul>
          <li>tests must be updated over time</li>
        </ul>
      </li>
      <li>an idea: automated testing
        <h3 id="landscape-of-testing">Landscape of Testing</h3>
        <h4 id="specifications">Specifications</h4>
      </li>
    </ul>
  </li>
  <li>Pre- and Post-conditions
    <h4 id="measuring-test-suite-quality">Measuring Test Suite Quality</h4>
  </li>
  <li>Coverage Metrics</li>
  <li>Mutation Analysis
    <h4 id="classification-of-testing-approaches">Classification of Testing Approaches</h4>
  </li>
</ul>
<figure>
  <img src="/assets/images/posts/2025-05-22-01.png" alt="Description" />
  <figcaption>Testing Approaches Matrix</figcaption>
</figure>
<ul>
  <li><strong>Manual vs Automated</strong> based on human participation, if the software require more human interaction =&gt; more manual testing</li>
  <li><strong>black-box:</strong> tester can see nothing about the tested program internal mechanisms. Testers can only issue inputs to the program, observe program outputs and determine whether the observed outputs meet the specifications required.</li>
  <li><strong>White-box</strong> refers to testing in which the internal details of the program being tested are fully available to the tester. The tester can use these internal details to perform a more precise analysis of the tested program and uncover inputs that are more likely to trigger buggy behavior.</li>
  <li><strong>Gray box approaches:</strong> testing behaviors need to not be strictly black box or white box.</li>
  <li>feedback directed random testing</li>
  <li>symbolic execution that needs to inspect source code</li>
  <li>dynamic analysis in order to discover future tests</li>
</ul>

<h3 id="automated-vs-manual-testing">Automated vs Manual Testing</h3>
<p>Automated Testing:</p>
<ul>
  <li>find bugs more quickly</li>
  <li>no need to write tests</li>
  <li>if software changes, no need to maintain tests
Manual Testing</li>
  <li>efficient test suite</li>
  <li>potentially better coverage</li>
</ul>

<h3 id="black-box-vs-white-box-testing">Black-box vs white-box testing</h3>
<p>Black-box testing:</p>
<ul>
  <li>can work with code that cannot be modified</li>
  <li>doesn’t need to analyze or study code</li>
  <li>code can be in any format (managed, binary, obfuscated)
White-box</li>
  <li>efficient test suite</li>
  <li>potentially better coverage</li>
</ul>

<h3 id="automated-testing-problem">Automated testing problem</h3>
<ul>
  <li>automated testing is hard to do</li>
  <li>probably impossible for entire systems</li>
  <li>certainly impossible without specifications
    <h3 id="pre--and-post-conditions">Pre- and post-conditions</h3>
    <p>A pre-condition is a predicate assumed to hold before a function executes, one use of it is to ensure that a function does not operate in an undefined way on inputs that it was not designed to handle.
A post-condition is a predicate expected to hold after a function executes whenever the pre-condition also holds, one use of it is to ensure that a function’s output matches its specification (i.e. a function that squares a real number should not output a negative number).</p>
  </li>
</ul>

<p>pre- and post-condition can be considered as a special case of assertions, which we saw in the first lesson</p>
<h4 id="condition-example">Condition Example</h4>
<figure>
  <img src="/assets/images/posts/2025-05-22-02.png" alt="Description" />
  <figcaption>Testing Approaches Matrix</figcaption>
</figure>

<p>This code defines a generic Stack class template with a single method. Let me break it down:
<strong>Class Structure:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">class Stack&lt;T&gt;</code> - This is a template class where <code class="language-plaintext highlighter-rouge">T</code> is a placeholder for any data type</li>
  <li><code class="language-plaintext highlighter-rouge">T[] array</code> - An array that stores elements of type <code class="language-plaintext highlighter-rouge">T</code></li>
  <li><code class="language-plaintext highlighter-rouge">int size</code> - Tracks the current number of elements in the stack</li>
  <li><code class="language-plaintext highlighter-rouge">pop()</code> is a <strong>stack operation</strong> that removes and returns the top element from the stack.</li>
</ul>

<p><strong>The pop() method:</strong></p>
<ul>
  <li><strong>Precondition:</strong> <code class="language-plaintext highlighter-rouge">s.size() &gt; 0</code> - The stack must not be empty before calling pop</li>
  <li><strong>Implementation:</strong> <code class="language-plaintext highlighter-rouge">return array[--size];</code> - This decrements the size counter and returns the element at that position</li>
  <li><strong>Postcondition:</strong> <code class="language-plaintext highlighter-rouge">s'.size() == s.size() - 1</code> - After the operation, the new size is one less than the original size</li>
</ul>

<p><strong>How it works:</strong> The <code class="language-plaintext highlighter-rouge">--size</code> is key here - it’s pre-decrement, so if the stack originally has 3 elements (size = 3), calling pop() will:</p>
<ol>
  <li>Decrement size from 3 to 2</li>
  <li>Return <code class="language-plaintext highlighter-rouge">array[2]</code> (the top element, since array indices are 0-based)</li>
</ol>

<p><strong>The size() method:</strong> Simply returns the current value of the <code class="language-plaintext highlighter-rouge">size</code> variable.</p>

<p><strong>Preconditions and Postconditions</strong> are formal specifications that define what must be true before and after a method executes. They’re part of <strong>Design by Contract</strong>, a programming methodology that treats software components like legal contracts.</p>

<p><strong>Preconditions</strong></p>
<ul>
  <li><strong>What:</strong> Conditions that must be true when a method is called</li>
  <li><strong>Who’s responsible:</strong> The caller must ensure these are met</li>
  <li><strong>Purpose:</strong> Define valid inputs and system states</li>
</ul>

<p><strong>Postconditions</strong></p>
<ul>
  <li><strong>What:</strong> Conditions guaranteed to be true when a method returns successfully</li>
  <li><strong>Who’s responsible:</strong> The method implementation must ensure these hold</li>
  <li><strong>Purpose:</strong> Define what the method promises to deliver</li>
</ul>

<p><strong>How They Work with Assertions</strong>
Assertions are runtime checks that verify these contracts:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">T</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Precondition assertion</span>
    <span class="k">assert</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">:</span> <span class="s">"Stack is empty - cannot pop"</span><span class="o">;</span>
    
    <span class="no">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">array</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
    
    <span class="c1">// Postcondition assertion  </span>
    <span class="k">assert</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">:</span> <span class="s">"Size became negative after pop"</span><span class="o">;</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="more">More..</h4>
<p>Pre- and post-conditions</p>
<ul>
  <li>Most useful if they are executable
    <ul>
      <li>written in the programming language itself</li>
      <li>a special case of assertions</li>
    </ul>
  </li>
  <li>Need not be precise
    <ul>
      <li>may become more complex than the code</li>
      <li>but useful even if they do not cover every situation
        <h4 id="process-of-using-pre--and-post-conditions">Process of using Pre- and post-conditions</h4>
      </li>
    </ul>
  </li>
</ul>
<figure>
  <img src="/assets/images/posts/2025-05-22-03.png" alt="Description" />
  <figcaption>Pre- and Post-Condition</figcaption>
</figure>
<p>this framework doesn’t help write tests, but help with automating testing runs</p>

<figure>
  <img src="/assets/images/posts/2025-05-22-04.png" alt="Description" />
  <figcaption>Executable Post-conditions</figcaption>
</figure>

<h3 id="how-good-is-your-test-suit">How good is your test suit?</h3>
<ul>
  <li>how do we know that our test suite is good?
    <ul>
      <li>too few tests: may miss bugs</li>
      <li>too many tests.: costly to run, bloat and redundancy, harder to maintain</li>
    </ul>
  </li>
  <li>two approaches
    <ul>
      <li>code coverage metrics</li>
      <li>mutation analysis (or mutation testing)
        <h4 id="code-coverage">Code coverage</h4>
      </li>
    </ul>
  </li>
  <li>Metric to quantify extent to which a program’s code is tested by a given test suite</li>
  <li>Given as percentage of some aspect of the program executed in the tests</li>
  <li>Function coverage: fucntions called</li>
  <li>statement coverage: statements executed</li>
  <li>branch coverage: branches taken</li>
  <li>
    <h4 id="mutation-analysis">Mutation Analysis</h4>
  </li>
</ul>

<hr />

<h1 id="references">References</h1>]]></content><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><summary type="html"><![CDATA[Status: #review #knowledge Tags: #SAT #testing #softwaredev]]></summary></entry><entry><title type="html">conda vs venv</title><link href="http://localhost:4000/2024/10/20/conda-vs-venv.html" rel="alternate" type="text/html" title="conda vs venv" /><published>2024-10-20T00:00:00-04:00</published><updated>2024-10-20T00:00:00-04:00</updated><id>http://localhost:4000/2024/10/20/conda-vs-venv</id><content type="html" xml:base="http://localhost:4000/2024/10/20/conda-vs-venv.html"><![CDATA[<p>conda needs a environment.yaml file to determine the packages needed</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-m</span> venv .venv
<span class="nb">source </span>myvenv/bin/activate
which python
pip <span class="nb">install</span> <span class="nt">-r</span> /Users/requirements.txt
pip3 uninstall <span class="nt">-r</span> requirements.txt <span class="nt">-y</span>
</code></pre></div></div>

<p>The only solution I found was to delete the <code class="language-plaintext highlighter-rouge">venv</code> and recreate it. I followed these steps but I’ll provide a brief summary for Windows:</p>

<ol>
  <li>Activate your virtualenv. Go to the parent folder where your Virtual Environment is located and run <code class="language-plaintext highlighter-rouge">venv\scripts\activate</code>. Keep in mind that the first name “venv” can vary.</li>
  <li>Create a requirements.txt file. <code class="language-plaintext highlighter-rouge">pip freeze requirements.txt</code></li>
  <li><code class="language-plaintext highlighter-rouge">deactivate</code> to exit the venv</li>
  <li><code class="language-plaintext highlighter-rouge">rm venv</code> to delete the venv</li>
  <li><code class="language-plaintext highlighter-rouge">py -m venv venv</code> to create a new one</li>
  <li><code class="language-plaintext highlighter-rouge">pip install -r requirements.txt</code> to install the requirements.</li>
</ol>

<p>to make sure install all the packages in requirements.txt</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>requirements.txt | <span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'/^\s*#.*$/d'</span> <span class="nt">-e</span> <span class="s1">'/^\s*$/d'</span> | xargs <span class="nt">-n</span> 1 python <span class="nt">-m</span> pip <span class="nb">install</span>
</code></pre></div></div>]]></content><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><summary type="html"><![CDATA[conda needs a environment.yaml file to determine the packages needed]]></summary></entry></feed>