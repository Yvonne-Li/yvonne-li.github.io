<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en_US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en_US" /><updated>2025-06-07T14:53:27-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yvonne Li</title><subtitle>Hello Travellers!
</subtitle><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><entry><title type="html">LLVM IR Iteration</title><link href="http://localhost:4000/2025/06/07/LLVM-IR-Iteration.html" rel="alternate" type="text/html" title="LLVM IR Iteration" /><published>2025-06-07T00:00:00-04:00</published><updated>2025-06-07T00:00:00-04:00</updated><id>http://localhost:4000/2025/06/07/LLVM-IR-Iteration</id><content type="html" xml:base="http://localhost:4000/2025/06/07/LLVM-IR-Iteration.html"><![CDATA[<p><strong>STL-style</strong> refers to following the design patterns and conventions established by the <strong>Standard Template Library (STL)</strong>, which is a fundamental part of the C++ standard library.</p>

<h2 id="core-stl-design-patterns">Core STL Design Patterns</h2>

<h3 id="1-iterator-pattern">1. <strong>Iterator Pattern</strong></h3>

<p>STL uses iterators as a uniform way to traverse containers:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// STL vector example</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-common-interface-conventions">2. <strong>Common Interface Conventions</strong></h3>

<p>STL containers share consistent method names:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">begin()</code> / <code class="language-plaintext highlighter-rouge">end()</code> - start/end iterators</li>
  <li><code class="language-plaintext highlighter-rouge">size()</code> - number of elements</li>
  <li><code class="language-plaintext highlighter-rouge">empty()</code> - check if container is empty</li>
  <li><code class="language-plaintext highlighter-rouge">insert()</code> / <code class="language-plaintext highlighter-rouge">erase()</code> - add/remove elements</li>
</ul>

<h3 id="3-template-based-design">3. <strong>Template-Based Design</strong></h3>

<p>STL heavily uses templates for type safety and reusability:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</code></pre></div></div>

<h2 id="how-llvm-adopts-stl-style">How LLVM Adopts STL-Style</h2>

<p>LLVM IR classes follow these same patterns:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// LLVM follows STL conventions</span>
<span class="n">Function</span><span class="o">*</span> <span class="n">F</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>

<span class="c1">// STL-style iteration</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Function</span><span class="o">::</span><span class="n">iterator</span> <span class="n">BB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">BB</span> <span class="o">!=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">BB</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">BB</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// process instruction</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// STL-style methods</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>          <span class="c1">// Like STL containers</span>
    <span class="kt">size_t</span> <span class="n">numBB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="c1">// Like STL containers</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="stl-iterator-categories">STL Iterator Categories</h2>

<p>STL defines different iterator types that LLVM also follows:</p>

<table>
  <thead>
    <tr>
      <th>Iterator Type</th>
      <th>Capabilities</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Input Iterator</strong></td>
      <td>Read-only, forward only</td>
      <td><code class="language-plaintext highlighter-rouge">istream_iterator</code></td>
    </tr>
    <tr>
      <td><strong>Output Iterator</strong></td>
      <td>Write-only, forward only</td>
      <td><code class="language-plaintext highlighter-rouge">ostream_iterator</code></td>
    </tr>
    <tr>
      <td><strong>Forward Iterator</strong></td>
      <td>Read/write, forward only</td>
      <td><code class="language-plaintext highlighter-rouge">forward_list::iterator</code></td>
    </tr>
    <tr>
      <td><strong>Bidirectional Iterator</strong></td>
      <td>Read/write, forward/backward</td>
      <td><code class="language-plaintext highlighter-rouge">list::iterator</code></td>
    </tr>
    <tr>
      <td><strong>Random Access Iterator</strong></td>
      <td>Read/write, jump to any position</td>
      <td><code class="language-plaintext highlighter-rouge">vector::iterator</code></td>
    </tr>
  </tbody>
</table>

<h2 id="stl-style-benefits">STL-Style Benefits</h2>

<h3 id="1-familiar-interface">1. <strong>Familiar Interface</strong></h3>

<p>C++ developers already know these patterns:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This feels familiar to anyone who knows STL</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Module</span><span class="o">::</span><span class="n">iterator</span> <span class="n">F</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">F</span> <span class="o">!=</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// process function</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-generic-algorithms">2. <strong>Generic Algorithms</strong></h3>

<p>Works with STL algorithms:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="c1">// Count functions in a module</span>
<span class="kt">size_t</span> <span class="n">funcCount</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// Find a specific function</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
    <span class="p">[](</span><span class="k">const</span> <span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">F</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">==</span> <span class="s">"main"</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div></div>

<h3 id="3-range-based-for-loops-c11">3. <strong>Range-Based For Loops</strong> (C++11+)</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Modern C++ range-based for loop works because of STL-style design</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">F</span> <span class="o">:</span> <span class="n">M</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">BB</span> <span class="o">:</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">I</span> <span class="o">:</span> <span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// process instruction</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="available-iterator-types-in-llvm">Available Iterator Types in LLVM</h2>

<p>From the document, LLVM provides these STL-style iterator types:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Different iterator types for different LLVM structures</span>
<span class="n">Module</span><span class="o">::</span><span class="n">iterator</span>        <span class="c1">// Iterates over functions in a module</span>
<span class="n">Function</span><span class="o">::</span><span class="n">iterator</span>      <span class="c1">// Iterates over basic blocks in a function  </span>
<span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span>    <span class="c1">// Iterates over instructions in a basic block</span>
<span class="n">Value</span><span class="o">::</span><span class="n">use_iterator</span>     <span class="c1">// Iterates over uses of a value</span>
<span class="n">User</span><span class="o">::</span><span class="n">op_iterator</span>       <span class="c1">// Iterates over operands of a user</span>
</code></pre></div></div>

<h2 id="comparison-stl-style-vs-custom-approaches">Comparison: STL-Style vs Custom Approaches</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// STL-style (what LLVM uses)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Function</span><span class="o">::</span><span class="n">iterator</span> <span class="n">BB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">BB</span> <span class="o">!=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Standard, predictable interface</span>
<span class="p">}</span>

<span class="c1">// Hypothetical custom approach (what LLVM could have done differently)</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">getBasicBlockCount</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BasicBlock</span><span class="o">*</span> <span class="n">BB</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">getBasicBlock</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// Less familiar, inconsistent across different classes</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The STL-style approach makes LLVM more approachable for C++ developers because they can leverage their existing knowledge of STL patterns and conventions. This design choice reduces the learning curve and makes the API more intuitive and consistent.</p>]]></content><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><summary type="html"><![CDATA[STL-style refers to following the design patterns and conventions established by the Standard Template Library (STL), which is a fundamental part of the C++ standard library.]]></summary></entry><entry><title type="html">Software Testing</title><link href="http://localhost:4000/2025/05/22/Introduction-to-Software-Testing.html" rel="alternate" type="text/html" title="Software Testing" /><published>2025-05-22T00:00:00-04:00</published><updated>2025-05-22T00:00:00-04:00</updated><id>http://localhost:4000/2025/05/22/Introduction%20to%20Software%20Testing</id><content type="html" xml:base="http://localhost:4000/2025/05/22/Introduction-to-Software-Testing.html"><![CDATA[<p>Status: #review  #knowledge <br />
Tags: #SAT #testing #softwaredev</p>

<h1 id="cs6340-sat---introduction-to-software-testing">CS6340 SAT - Introduction to Software Testing</h1>
<h2 id="observations">Observations</h2>
<h3 id="the-need-for-specifications">the need for specifications</h3>
<ul>
  <li>testing checks whether program implementation agrees with program specification</li>
  <li>without a specification, there’s nothing to test</li>
  <li>testing a form of consistency checking between implementation and specification
    <ul>
      <li>recurring theme for software quality checking approaches</li>
      <li>what if implementation and specification are wrong?
        <h3 id="developer-tester">developer !=Tester</h3>
      </li>
    </ul>
  </li>
  <li>developer writes implementation, tester writes specification</li>
  <li>unlikely that both will independently make the same mistake</li>
  <li>Specifications useful even if written by developer itself
    <ul>
      <li>much simpler than implementation</li>
      <li>specification unlikely to have same mistake as implementation
        <h3 id="other-observations">Other observations</h3>
      </li>
    </ul>
  </li>
  <li>resources are finite
    <ul>
      <li>limit how many tests are written</li>
      <li>specifications evolve over time
        <ul>
          <li>tests must be updated over time</li>
        </ul>
      </li>
      <li>an idea: automated testing
        <h3 id="landscape-of-testing">Landscape of Testing</h3>
        <h4 id="specifications">Specifications</h4>
      </li>
    </ul>
  </li>
  <li>Pre- and Post-conditions
    <h4 id="measuring-test-suite-quality">Measuring Test Suite Quality</h4>
  </li>
  <li>Coverage Metrics</li>
  <li>Mutation Analysis
    <h4 id="classification-of-testing-approaches">Classification of Testing Approaches</h4>
  </li>
</ul>
<figure>
  <img src="/assets/images/posts/2025-05-22-01.png" alt="Description" />
  <figcaption>Testing Approaches Matrix</figcaption>
</figure>
<ul>
  <li><strong>Manual vs Automated</strong> based on human participation, if the software require more human interaction =&gt; more manual testing</li>
  <li><strong>black-box:</strong> tester can see nothing about the tested program internal mechanisms. Testers can only issue inputs to the program, observe program outputs and determine whether the observed outputs meet the specifications required.</li>
  <li><strong>White-box</strong> refers to testing in which the internal details of the program being tested are fully available to the tester. The tester can use these internal details to perform a more precise analysis of the tested program and uncover inputs that are more likely to trigger buggy behavior.</li>
  <li><strong>Gray box approaches:</strong> testing behaviors need to not be strictly black box or white box.</li>
  <li>feedback directed random testing</li>
  <li>symbolic execution that needs to inspect source code</li>
  <li>dynamic analysis in order to discover future tests</li>
</ul>

<h3 id="automated-vs-manual-testing">Automated vs Manual Testing</h3>
<p>Automated Testing:</p>
<ul>
  <li>find bugs more quickly</li>
  <li>no need to write tests</li>
  <li>if software changes, no need to maintain tests
Manual Testing</li>
  <li>efficient test suite</li>
  <li>potentially better coverage</li>
</ul>

<h3 id="black-box-vs-white-box-testing">Black-box vs white-box testing</h3>
<p>Black-box testing:</p>
<ul>
  <li>can work with code that cannot be modified</li>
  <li>doesn’t need to analyze or study code</li>
  <li>code can be in any format (managed, binary, obfuscated)
White-box</li>
  <li>efficient test suite</li>
  <li>potentially better coverage</li>
</ul>

<h3 id="automated-testing-problem">Automated testing problem</h3>
<ul>
  <li>automated testing is hard to do</li>
  <li>probably impossible for entire systems</li>
  <li>certainly impossible without specifications
    <h3 id="pre--and-post-conditions">Pre- and post-conditions</h3>
    <p>A pre-condition is a predicate assumed to hold before a function executes, one use of it is to ensure that a function does not operate in an undefined way on inputs that it was not designed to handle.
A post-condition is a predicate expected to hold after a function executes whenever the pre-condition also holds, one use of it is to ensure that a function’s output matches its specification (i.e. a function that squares a real number should not output a negative number).</p>
  </li>
</ul>

<p>pre- and post-condition can be considered as a special case of assertions, which we saw in the first lesson</p>
<h4 id="condition-example">Condition Example</h4>
<figure>
  <img src="/assets/images/posts/2025-05-22-02.png" alt="Description" />
  <figcaption>Testing Approaches Matrix</figcaption>
</figure>

<p>This code defines a generic Stack class template with a single method. Let me break it down:
<strong>Class Structure:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">class Stack&lt;T&gt;</code> - This is a template class where <code class="language-plaintext highlighter-rouge">T</code> is a placeholder for any data type</li>
  <li><code class="language-plaintext highlighter-rouge">T[] array</code> - An array that stores elements of type <code class="language-plaintext highlighter-rouge">T</code></li>
  <li><code class="language-plaintext highlighter-rouge">int size</code> - Tracks the current number of elements in the stack</li>
  <li><code class="language-plaintext highlighter-rouge">pop()</code> is a <strong>stack operation</strong> that removes and returns the top element from the stack.</li>
</ul>

<p><strong>The pop() method:</strong></p>
<ul>
  <li><strong>Precondition:</strong> <code class="language-plaintext highlighter-rouge">s.size() &gt; 0</code> - The stack must not be empty before calling pop</li>
  <li><strong>Implementation:</strong> <code class="language-plaintext highlighter-rouge">return array[--size];</code> - This decrements the size counter and returns the element at that position</li>
  <li><strong>Postcondition:</strong> <code class="language-plaintext highlighter-rouge">s'.size() == s.size() - 1</code> - After the operation, the new size is one less than the original size</li>
</ul>

<p><strong>How it works:</strong> The <code class="language-plaintext highlighter-rouge">--size</code> is key here - it’s pre-decrement, so if the stack originally has 3 elements (size = 3), calling pop() will:</p>
<ol>
  <li>Decrement size from 3 to 2</li>
  <li>Return <code class="language-plaintext highlighter-rouge">array[2]</code> (the top element, since array indices are 0-based)</li>
</ol>

<p><strong>The size() method:</strong> Simply returns the current value of the <code class="language-plaintext highlighter-rouge">size</code> variable.</p>

<p><strong>Preconditions and Postconditions</strong> are formal specifications that define what must be true before and after a method executes. They’re part of <strong>Design by Contract</strong>, a programming methodology that treats software components like legal contracts.</p>

<p><strong>Preconditions</strong></p>
<ul>
  <li><strong>What:</strong> Conditions that must be true when a method is called</li>
  <li><strong>Who’s responsible:</strong> The caller must ensure these are met</li>
  <li><strong>Purpose:</strong> Define valid inputs and system states</li>
</ul>

<p><strong>Postconditions</strong></p>
<ul>
  <li><strong>What:</strong> Conditions guaranteed to be true when a method returns successfully</li>
  <li><strong>Who’s responsible:</strong> The method implementation must ensure these hold</li>
  <li><strong>Purpose:</strong> Define what the method promises to deliver</li>
</ul>

<p><strong>How They Work with Assertions</strong>
Assertions are runtime checks that verify these contracts:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">T</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Precondition assertion</span>
    <span class="k">assert</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">:</span> <span class="s">"Stack is empty - cannot pop"</span><span class="o">;</span>
    
    <span class="no">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">array</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
    
    <span class="c1">// Postcondition assertion  </span>
    <span class="k">assert</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">:</span> <span class="s">"Size became negative after pop"</span><span class="o">;</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="more">More..</h4>
<p>Pre- and post-conditions</p>
<ul>
  <li>Most useful if they are executable
    <ul>
      <li>written in the programming language itself</li>
      <li>a special case of assertions</li>
    </ul>
  </li>
  <li>Need not be precise
    <ul>
      <li>may become more complex than the code</li>
      <li>but useful even if they do not cover every situation
        <h4 id="process-of-using-pre--and-post-conditions">Process of using Pre- and post-conditions</h4>
      </li>
    </ul>
  </li>
</ul>
<figure>
  <img src="/assets/images/posts/2025-05-22-03.png" alt="Description" />
  <figcaption>Pre- and Post-Condition</figcaption>
</figure>
<p>this framework doesn’t help write tests, but help with automating testing runs</p>

<figure>
  <img src="/assets/images/posts/2025-05-22-04.png" alt="Description" />
  <figcaption>Executable Post-conditions</figcaption>
</figure>

<h3 id="how-good-is-your-test-suit">How good is your test suit?</h3>
<ul>
  <li>how do we know that our test suite is good?
    <ul>
      <li>too few tests: may miss bugs</li>
      <li>too many tests.: costly to run, bloat and redundancy, harder to maintain</li>
    </ul>
  </li>
  <li>two approaches
    <ul>
      <li>code coverage metrics</li>
      <li>mutation analysis (or mutation testing)
        <h4 id="code-coverage">Code coverage</h4>
      </li>
    </ul>
  </li>
  <li>Metric to quantify extent to which a program’s code is tested by a given test suite</li>
  <li>Given as percentage of some aspect of the program executed in the tests</li>
  <li>Function coverage: fucntions called</li>
  <li>statement coverage: statements executed</li>
  <li>branch coverage: branches taken</li>
  <li>
    <h4 id="mutation-analysis">Mutation Analysis</h4>
  </li>
</ul>

<hr />

<h1 id="references">References</h1>]]></content><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><summary type="html"><![CDATA[Status: #review #knowledge Tags: #SAT #testing #softwaredev]]></summary></entry><entry><title type="html">Threads and Concurrency</title><link href="http://localhost:4000/2025/02/24/Threads-and-Concurrency.html" rel="alternate" type="text/html" title="Threads and Concurrency" /><published>2025-02-24T00:00:00-05:00</published><updated>2025-02-24T00:00:00-05:00</updated><id>http://localhost:4000/2025/02/24/Threads%20and%20Concurrency</id><content type="html" xml:base="http://localhost:4000/2025/02/24/Threads-and-Concurrency.html"><![CDATA[<h1 id="comprehensive-analysis-of-threads-and-concurrency-in-modern-computing">Comprehensive Analysis of Threads and Concurrency in Modern Computing</h1>

<p>The study of threads and concurrency represents a cornerstone of modern computing systems, enabling efficient resource utilization and parallel task execution. This report synthesizes key concepts from foundational literature on multithreading architectures, synchronization mechanisms, and implementation patterns. By examining process-thread relationships, synchronization primitives like mutexes and condition variables, and advanced concurrency challenges including deadlock scenarios, we establish a framework for understanding how concurrent programming paradigms achieve performance gains while managing complexity. The analysis extends to kernel/user-level thread models and design patterns that optimize thread utilization, providing critical insights into balancing computational efficiency with robust error handling in multithreaded environments1.</p>

<h2 id="fundamental-concepts-of-execution-contexts">Fundamental Concepts of Execution Contexts</h2>

<h2 id="process-vs-thread-architectures">Process vs. Thread Architectures</h2>

<p>At the core of execution management lies the distinction between processes and threads. Processes operate as independent execution units with dedicated virtual address spaces, program counters, and system resources, while threads represent lightweight execution contexts sharing a common virtual address space within a process. This shared memory model enables threads to access global variables and heap memory without inter-process communication overhead, making them particularly effective for fine-grained parallelism1.</p>

<p>The process control block (PCB) structure demonstrates this dichotomy – while processes require separate PCBs tracking memory maps and resource handles, threads utilize a simplified execution context record focusing primarily on register states and stack pointers. This architectural difference directly impacts memory consumption, with multithreaded applications requiring significantly less memory overhead compared to multiprocess implementations for equivalent workloads1.</p>

<h2 id="motivations-for-multithreaded-programming">Motivations for Multithreaded Programming</h2>

<h2 id="performance-optimization-strategies">Performance Optimization Strategies</h2>

<p>Thread adoption primarily addresses three computational challenges:</p>

<ol>
  <li>
    <p><strong>Parallelization Speedup</strong>: Leveraging multiple processors/cores through true parallel execution</p>
  </li>
  <li>
    <p><strong>Specialization Efficiency</strong>: Dedicating threads to specific task types (I/O-bound vs CPU-bound operations)</p>
  </li>
  <li>
    <p><strong>Cache Optimization</strong>: Maintaining hot caches through context preservation within shared memory spaces</p>
  </li>
</ol>

<p>Single-CPU multithreading demonstrates surprising utility through intelligent context switching. When thread T1 enters an idle state (awaiting I/O completion or timer events), the scheduler activates thread T2 provided the context switching cost (T_ctx_switch) satisfies T_idle &gt; 2·T_ctx_switch. This hidden parallelism enables better hardware utilization even on single-core systems1.</p>

<h2 id="concurrency-control-mechanisms">Concurrency Control Mechanisms</h2>

<h2 id="mutual-exclusion-mutex-implementation">Mutual Exclusion (Mutex) Implementation</h2>

<p>The mutex primitive enforces exclusive access to critical sections through lock acquisition protocols. Birrell’s proposed syntax encapsulates critical sections within lock-bound blocks, ensuring automatic release upon exit. Modern implementations typically require explicit lock/unlock calls, with strict ordering constraints to prevent race conditions1.</p>

<pre><code class="language-C">pthread_mutex_lock(&amp;mutex);
// Critical section operations
pthread_mutex_unlock(&amp;mutex);

</code></pre>
<p>Mutex fairness guarantees remain implementation-dependent – threads requesting locks during an active critical section may acquire access in arbitrary order once released. This non-determinism necessitates careful design to prevent thread starvation scenarios1.</p>

<h2 id="condition-variable-semantics">Condition Variable Semantics</h2>

<p>Condition variables address the busy-wait problem through event-driven signaling. The wait() operation atomically releases the associated mutex and suspends the thread until a signal/broadcast occurs, then re-acquires the mutex before resuming execution. This dual-state management prevents missed signals while maintaining mutex consistency1.</p>

<pre><code class="language-C">// Consumer thread
pthread_mutex_lock(&amp;mutex);
while (!condition_met) {
    pthread_cond_wait(&amp;cond_var, &amp;mutex);
}
// Process condition
pthread_mutex_unlock(&amp;mutex);

// Producer thread
pthread_mutex_lock(&amp;mutex);
condition_met = 1;
pthread_cond_signal(&amp;cond_var);
pthread_mutex_unlock(&amp;mutex);
</code></pre>

<h2 id="synchronization-challenges-and-solutions">Synchronization Challenges and Solutions</h2>

<h2 id="reader-writer-problem-dynamics">Reader-Writer Problem Dynamics</h2>

<p>The reader-writer problem exemplifies synchronization complexity when managing shared resources. Naive mutex implementations serializing all access prove inefficient for read-heavy workloads. Enhanced solutions employ:</p>

<ul>
  <li>
    <p>Reader counters with associated mutexes</p>
  </li>
  <li>
    <p>Separate write mutex for exclusive access</p>
  </li>
  <li>
    <p>Priority policies favoring either readers or writers</p>
  </li>
</ul>

<p>This separation allows concurrent reads while ensuring write operations maintain data consistency. Implementation typically involves layered mutex locks and condition variables to coordinate access states1.</p>

<h2 id="deadlock-characterization-and-mitigation">Deadlock Characterization and Mitigation</h2>

<p>Deadlock manifests through circular wait dependencies between threads holding conflicting resources. The classical example involves two threads each holding one mutex while requesting the other:</p>

<pre><code class="language-C">// Thread 1
lock(mutex_A);
lock(mutex_B);  // Blocks if Thread 2 holds mutex_B

// Thread 2
lock(mutex_B);
lock(mutex_A);  // Blocks if Thread 1 holds mutex_A
</code></pre>

<p>Prevention strategies emphasize:</p>

<ol>
  <li>
    <p><strong>Lock Ordering Consistency</strong>: Enforcing global acquisition order for mutexes</p>
  </li>
  <li>
    <p><strong>Timeout Mechanisms</strong>: Implementing try-lock with backoff periods</p>
  </li>
  <li>
    <p><strong>Deadlock Detection</strong>: Maintaining resource allocation graphs for cycle detection</p>
  </li>
</ol>

<p>The Ostrich algorithm (ignoring deadlocks) remains controversially viable for systems where deadlock probability is statistically negligible compared to recovery costs1.</p>

<h2 id="thread-implementation-models">Thread Implementation Models</h2>

<h2 id="kernel-level-vs-user-level-threads">Kernel-Level vs User-Level Threads</h2>

<p>Kernel threads enjoy direct OS scheduling support but incur significant context-switching overhead. User-level threads managed by runtime libraries enable lightweight context switches but risk entire process blocking on single-thread syscalls. Hybrid models attempt to balance these tradeoffs:</p>

<p>Characteristic</p>

<p>Kernel Threads</p>

<p>User Threads</p>

<p>Scheduling</p>

<p>OS-managed</p>

<p>Library-managed</p>

<p>Context Switch Cost</p>

<p>High (mode transition)</p>

<p>Low (in-process)</p>

<p>Blocking Behavior</p>

<p>Per-thread</p>

<p>Process-wide</p>

<p>Parallelism</p>

<p>True multi-core</p>

<p>Single-core emulation</p>

<h2 id="thread-mapping-architectures">Thread Mapping Architectures</h2>

<p>Three primary models govern user-kernel thread relationships:</p>

<ol>
  <li>
    <p><strong>One-to-One</strong>: Direct user-kernel thread mapping enabling true parallelism but limited scalability</p>
  </li>
  <li>
    <p><strong>Many-to-One</strong>: Multiple user threads on single kernel thread risking complete blockage on syscalls</p>
  </li>
  <li>
    <p><strong>Many-to-Many</strong>: Hybrid pool model balancing parallelism and lightweight context management</p>
  </li>
</ol>

<p>Modern systems increasingly adopt the many-to-many model through thread pools and work-stealing algorithms, particularly in NUMA architectures where memory locality significantly impacts performance1.</p>

<h2 id="multithreading-design-patterns">Multithreading Design Patterns</h2>

<h2 id="boss-worker-task-distribution">Boss-Worker Task Distribution</h2>

<p>This pattern separates task generation (boss) from execution (worker pool). A shared queue mediates communication, with workers continuously dequeuing tasks. Key considerations include:</p>

<ul>
  <li>
    <p>Queue synchronization using mutexes and condition variables</p>
  </li>
  <li>
    <p>Dynamic worker scaling based on load</p>
  </li>
  <li>
    <p>Work stealing between idle workers</p>
  </li>
</ul>

<pre><code class="language-C">struct TaskQueue {
    pthread_mutex_t lock;
    pthread_cond_t non_empty;
    Task* front;
};

void* worker_thread(void* arg) {
    while (1) {
        pthread_mutex_lock(&amp;queue.lock);
        while (queue.front == NULL) {
            pthread_cond_wait(&amp;queue.non_empty, &amp;queue.lock);
        }
        Task* task = dequeue_task();
        pthread_mutex_unlock(&amp;queue.lock);
        execute_task(task);
    }
}
</code></pre>

<h2 id="pipeline-processing-model">Pipeline Processing Model</h2>

<p>Breaking tasks into sequential stages handled by dedicated thread pools enables assembly-line parallelism. Each pipeline stage maintains its own synchronization queue, with throughput limited by the slowest stage. Effective buffer sizing between stages prevents producer-consumer bottlenecks1.</p>

<h2 id="layered-execution-strategy">Layered Execution Strategy</h2>

<p>Similar to network protocol stacks, layered threading isolates functional components into hierarchical groups. Requests propagate vertically through layers, with each layer potentially employing its own concurrency model. This proves particularly effective in server architectures handling authentication, processing, and response stages as distinct layers1.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Modern concurrent programming demands meticulous attention to synchronization primitives, execution models, and architectural patterns. While mutexes and condition variables provide foundational coordination mechanisms, their effective use requires deep understanding of deadlock scenarios and spurious wakeup mitigation. The choice between kernel and user-level threading models significantly impacts both performance and program complexity, necessitating architecture-specific optimizations.</p>

<p>Emerging hardware trends like heterogeneous computing and non-uniform memory access architectures will likely drive evolution in threading paradigms. Future research directions should investigate machine learning-assisted deadlock detection and context-aware scheduling algorithms. Practitioners must balance theoretical synchronization principles with empirical performance profiling to achieve optimal concurrency implementations1.</p>

<h3 id="citations">Citations:</h3>

<ol>
  <li><a href="https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/31164939/2d2eb09b-1951-4725-9344-c964a1565eb8/P2L2_-_Threads_and_Concurrency.pdf">https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/31164939/2d2eb09b-1951-4725-9344-c964a1565eb8/P2L2_-_Threads_and_Concurrency.pdf</a></li>
</ol>

<p>An Introduction to Programming with Threads by  Andrew D. Birrell</p>

<hr />

<p>Answer from Perplexity: <a href="pplx.ai/share">pplx.ai/share</a></p>]]></content><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><summary type="html"><![CDATA[Comprehensive Analysis of Threads and Concurrency in Modern Computing]]></summary></entry><entry><title type="html">conda vs venv</title><link href="http://localhost:4000/2024/10/20/conda-vs-venv.html" rel="alternate" type="text/html" title="conda vs venv" /><published>2024-10-20T00:00:00-04:00</published><updated>2024-10-20T00:00:00-04:00</updated><id>http://localhost:4000/2024/10/20/conda-vs-venv</id><content type="html" xml:base="http://localhost:4000/2024/10/20/conda-vs-venv.html"><![CDATA[<p>conda needs a environment.yaml file to determine the packages needed</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-m</span> venv .venv
<span class="nb">source </span>myvenv/bin/activate
which python
pip <span class="nb">install</span> <span class="nt">-r</span> /Users/requirements.txt
pip3 uninstall <span class="nt">-r</span> requirements.txt <span class="nt">-y</span>
</code></pre></div></div>

<p>The only solution I found was to delete the <code class="language-plaintext highlighter-rouge">venv</code> and recreate it. I followed these steps but I’ll provide a brief summary for Windows:</p>

<ol>
  <li>Activate your virtualenv. Go to the parent folder where your Virtual Environment is located and run <code class="language-plaintext highlighter-rouge">venv\scripts\activate</code>. Keep in mind that the first name “venv” can vary.</li>
  <li>Create a requirements.txt file. <code class="language-plaintext highlighter-rouge">pip freeze requirements.txt</code></li>
  <li><code class="language-plaintext highlighter-rouge">deactivate</code> to exit the venv</li>
  <li><code class="language-plaintext highlighter-rouge">rm venv</code> to delete the venv</li>
  <li><code class="language-plaintext highlighter-rouge">py -m venv venv</code> to create a new one</li>
  <li><code class="language-plaintext highlighter-rouge">pip install -r requirements.txt</code> to install the requirements.</li>
</ol>

<p>to make sure install all the packages in requirements.txt</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>requirements.txt | <span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'/^\s*#.*$/d'</span> <span class="nt">-e</span> <span class="s1">'/^\s*$/d'</span> | xargs <span class="nt">-n</span> 1 python <span class="nt">-m</span> pip <span class="nb">install</span>
</code></pre></div></div>]]></content><author><name>Yvonne Li</name><email>yvonneli.dev@gmail.com</email></author><summary type="html"><![CDATA[conda needs a environment.yaml file to determine the packages needed]]></summary></entry></feed>